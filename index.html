</span>
                            </label>
                            <button v-if="isEditMode" @click="exportCoordinates" class="text-xs bg-blue-600 text-white px-2 py-1 rounded hover:bg-blue-700 shadow">üíæ {{ t.exportData }}</button>
                        </div>
                    </div>

                    <!-- Export Controls -->
                    <div class="bg-white/90 backdrop-blur rounded-lg shadow border px-3 py-2 flex flex-col gap-1 w-44">
                        <div class="flex items-center gap-2">
                            <span class="text-[10px] font-bold text-gray-500 uppercase w-8">Icon</span>
                            <input type="range" v-model.number="exportIconScale" min="20" max="300" step="10" class="flex-grow">
                            <span class="text-[10px] font-mono text-blue-600 w-8 text-right">{{ exportIconScale }}%</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <span class="text-[10px] font-bold text-gray-500 uppercase w-8">Text</span>
                            <input type="range" v-model.number="exportTextScale" min="0" max="300" step="10" class="flex-grow">
                            <span class="text-[10px] font-mono text-blue-600 w-8 text-right">{{ exportTextScale }}%</span>
                        </div>
                    </div>

                    <div class="flex flex-row gap-2">
                        <button @click="exportFullMap" class="bg-white/90 backdrop-blur hover:bg-white text-gray-700 px-3 py-2 rounded-lg shadow border transition font-bold text-sm" title="Export JPG">üíæ JPG</button>
                        <button @click="toggleFullScreen" class="bg-white/90 backdrop-blur hover:bg-white text-gray-700 px-3 py-2 rounded-lg shadow border transition">{{ isFullScreen ? 'üóó' : '‚õ∂' }}</button>
                        <button @click="hideMapControls = !hideMapControls" class="bg-white/90 backdrop-blur hover:bg-white text-gray-700 px-3 py-2 rounded-lg shadow border transition">{{ hideMapControls ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è' }}</button>
                    </div>
                </div>

                <div id="map-container"></div>
                
                <!-- Layer Control -->
                <div class="absolute bottom-6 right-6 z-[1000] transition-all duration-300 transform" :class="{'translate-y-[150%]': hideMapControls}">
                    <div class="bg-white/95 backdrop-blur rounded-lg shadow-2xl border border-gray-200 w-64 overflow-hidden">
                        <div class="bg-gray-100 p-2 border-b flex justify-between items-center cursor-pointer" @click="showLayers = !showLayers">
                            <span class="font-bold text-xs text-gray-700">üìö {{ t.layerControl }}</span>
                            <span class="text-xs">{{ showLayers ? '‚ñº' : '‚ñ≤' }}</span>
                        </div>
                        <div v-show="showLayers" class="p-3 max-h-96 overflow-y-auto no-scrollbar">
                            <div class="mb-4">
                                <h5 class="text-[10px] font-bold text-gray-400 uppercase mb-2 tracking-wider flex justify-between">{{ t.layerEra }} (Shape) <button @click="toggleAll('eras')" class="text-blue-500 hover:underline">All</button></h5>
                                <div class="space-y-1">
                                    <label v-for="(shape, eraKey) in eraShapes" :key="eraKey" class="flex items-center text-xs cursor-pointer hover:bg-gray-50 p-1 rounded">
                                        <input type="checkbox" v-model="visibleLayers.eras" :value="eraKey" class="mr-2 rounded text-blue-600 focus:ring-blue-500">
                                        <svg width="14" height="14" viewBox="0 0 20 20" class="mr-2"><path :d="getSvgPath(shape)" fill="#666" stroke="none" transform="translate(2,2) scale(0.8)"/></svg>
                                        {{ t['era'+eraKey] || eraKey }}
                                    </label>
                                </div>
                            </div>
                            <div>
                                <h5 class="text-[10px] font-bold text-gray-400 uppercase mb-2 tracking-wider flex justify-between">{{ t.layerCategory }} (Color) <div><button @click="resetColors" class="text-gray-400 hover:text-red-500 mr-2">‚Ü∫</button><button @click="toggleAll('cats')" class="text-blue-500 hover:underline">All</button></div></h5>
                                <div class="space-y-1">
                                    <label v-for="(color, catKey) in customColors" :key="catKey" class="flex items-center text-xs cursor-pointer hover:bg-gray-50 p-1 rounded">
                                        <input type="checkbox" v-model="visibleLayers.cats" :value="catKey" class="mr-2 rounded text-blue-600 focus:ring-blue-500">
                                        <input type="color" v-model="customColors[catKey]" class="color-picker">
                                        {{ t['major'+catKey] || catKey }}
                                    </label>
                                </div>
                            </div>
                            <div class="mt-4 pt-2 border-t border-gray-200">
                                <h5 class="text-[10px] font-bold text-gray-400 uppercase mb-2 tracking-wider">Special</h5>
                                <label class="flex items-center text-xs cursor-pointer hover:bg-gray-50 p-1 rounded">
                                    <input type="checkbox" v-model="showParenthesesLayer" class="mr-2 rounded text-black focus:ring-black">
                                    <span class="w-3 h-3 rounded-full bg-black mr-2 shadow-sm border border-gray-200"></span>
                                    {{ t.layerParentheses }}
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div v-if="mapError" class="absolute inset-0 z-[500] flex items-center justify-center bg-gray-100">
                    <div class="bg-white p-8 rounded-xl shadow-xl text-center max-w-md">
                        <div class="text-4xl mb-4">üó∫Ô∏è</div>
                        <h3 class="text-xl font-bold mb-2">Map Image Not Found</h3>
                        <input type="file" accept="image/*" @change="loadLocalImage" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"/>
                    </div>
                </div>
            </div>
        </main>

        <!-- Detail Modal -->
        <div id="detail-modal" style="display: none;" v-show="selectedItem" class="fixed inset-0 z-[3000] overflow-y-auto" role="dialog">
            <div class="flex items-center justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0">
                <div class="fixed inset-0 bg-gray-900 bg-opacity-75 transition-opacity" @click="closeModal"></div>
                <div v-if="selectedItem" class="inline-block align-bottom bg-white rounded-lg text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-2xl w-full">
                    <div class="bg-white px-4 pt-5 pb-4 sm:p-6">
                        <div class="flex justify-between items-center mb-4 border-b pb-2">
                            <div class="flex gap-2">
                                <span class="bg-blue-600 text-white text-sm font-bold px-3 py-1 rounded">ID: {{ selectedItem.id }}</span>
                                <span v-if="selectedItem.map_sheet" class="bg-purple-100 text-purple-800 border border-purple-200 text-sm font-bold px-3 py-1 rounded">üó∫Ô∏è {{ selectedItem.map_sheet }}</span>
                            </div>
                            <button @click="closeModal" class="text-gray-400 hover:text-gray-600 text-2xl font-bold">&times;</button>
                        </div>
                        <h3 class="text-2xl font-bold text-gray-900 mb-2">{{ selectedItem.name }}</h3>
                        
                        <div class="flex flex-wrap gap-2 mb-4">
                             <span class="inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-yellow-50 text-yellow-800 border border-yellow-200">üìÖ {{ selectedItem.dating }}</span>
                             <span class="inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-gray-100 text-gray-700 border border-gray-200">‚è≥ {{ getShortEra(selectedItem.dating) }}</span>
                             <span v-if="getCategoryInfo(selectedItem)" :class="`inline-flex items-center px-2 py-1 rounded text-xs font-medium border`" :style="getCategoryInfo(selectedItem).style">{{ getCategoryInfo(selectedItem).label }} - {{ getSubCategoryLabel(selectedItem) }}</span>
                        </div>

                        <!-- ËΩÆÊí≠ÁªÑ‰ª∂ (‰ºòÂåñÁâà) -->
                        <div class="mb-4 relative group bg-gray-100 rounded-lg overflow-hidden border border-gray-200 flex items-center justify-center" style="min-height: 200px; height: 320px;">
                            <div v-if="selectedItem.image_paths && selectedItem.image_paths.length > 0" class="w-full h-full flex items-center justify-center bg-gray-50 relative">
                                
                                <!-- Loading Spinner -->
                                <div v-if="isImageLoading" class="absolute inset-0 flex items-center justify-center z-10 text-blue-500">
                                    <svg class="animate-spin h-8 w-8" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                </div>

                                <img :src="selectedItem.image_paths[currentImageIndex]" 
                                     @click="openLightbox"
                                     @load="onImageLoad"
                                     v-show="!isImageLoading"
                                     class="max-w-full max-h-full object-contain transition-opacity duration-300 cursor-zoom-in shadow-sm z-1" 
                                     alt="Monument Image">
                                
                                <div v-if="selectedItem.image_paths.length > 1">
                                    <button @click.stop="prevImage" class="absolute left-2 top-1/2 -translate-y-1/2 bg-black/30 hover:bg-black/60 text-white rounded-full p-2 transition backdrop-blur-sm z-20">‚ùÆ</button>
                                    <button @click.stop="nextImage" class="absolute right-2 top-1/2 -translate-y-1/2 bg-black/30 hover:bg-black/60 text-white rounded-full p-2 transition backdrop-blur-sm z-20">‚ùØ</button>
                                    <div class="absolute bottom-2 left-1/2 -translate-x-1/2 bg-black/50 text-white text-xs px-3 py-1 rounded-full backdrop-blur-sm z-20">{{ currentImageIndex + 1 }} / {{ selectedItem.image_paths.length }}</div>
                                </div>
                            </div>
                            <div v-else class="flex flex-col items-center justify-center text-gray-400">
                                <span class="text-4xl opacity-20 mb-2">üì∑</span>
                                <span class="text-sm">ÊöÇÊó†ÂõæÁâá (No Image)</span>
                            </div>
                        </div>

                        <p class="text-sm text-gray-700 leading-relaxed whitespace-pre-line bg-gray-50 p-4 rounded">{{ selectedItem.description }}</p>
                    </div>
                    
                    <!-- Modal Footer -->
                    <div class="bg-gray-100 px-4 py-3 sm:px-6 sm:flex sm:flex-row-reverse gap-2">
                         <a :href="googleTranslateUrl" target="_blank" class="w-full inline-flex justify-center rounded-md border border-gray-300 shadow-sm px-4 py-2 bg-white text-base font-medium text-gray-700 hover:bg-gray-50 sm:mt-0 sm:ml-3 sm:w-auto sm:text-sm">üåê Translate</a>
                         
                         <!-- ‰∏ãËΩΩÊâÄÊúâÂõæÁâáÊåâÈíÆ -->
                         <button v-if="selectedItem && selectedItem.image_paths && selectedItem.image_paths.length > 0" 
                                 type="button" 
                                 @click="downloadImages"
                                 :disabled="downloading"
                                 class="w-full inline-flex justify-center rounded-md border border-gray-300 shadow-sm px-4 py-2 bg-white text-base font-medium text-gray-700 hover:bg-gray-50 sm:mt-0 sm:ml-3 sm:w-auto sm:text-sm">
                             {{ downloading ? '‚è≥ Zipping...' : 'üì¶ Download All Images' }}
                         </button>

                         <button type="button" class="w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-blue-600 text-base font-medium text-white hover:bg-blue-700 sm:ml-3 sm:w-auto sm:text-sm" @click="closeModal">Close</button>
                         <button v-if="isEditMode && savedCoordinates[selectedItem.id]" type="button" class="w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-red-600 text-base font-medium text-white hover:bg-red-700 sm:ml-3 sm:w-auto sm:text-sm" @click="deleteMarker(selectedItem.id)">üóëÔ∏è Remove Marker</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- ‚òÖ‚òÖ‚òÖ ÂäüËÉΩ 1ÔºöÂÖ®Â±èÂõæÁâáÁÅØÁÆ± (Lightbox) - ‰ºòÂåñÁâà ‚òÖ‚òÖ‚òÖ -->
        <div v-if="isLightboxOpen && selectedItem && selectedItem.image_paths && selectedItem.image_paths.length > 0" 
             class="fixed inset-0 z-[4000] bg-black bg-opacity-95 flex items-center justify-center overflow-hidden"
             @click.self="closeLightbox">
            
            <!-- ÂÖ≥Èó≠ÊåâÈíÆ -->
            <button @click="closeLightbox" class="absolute top-4 right-4 text-white text-4xl hover:text-gray-300 z-[4001]">&times;</button>
            
            <!-- Â∑¶ÁÆ≠Â§¥ -->
            <button v-if="selectedItem.image_paths.length > 1" @click.stop="prevImage" class="absolute left-4 top-1/2 -translate-y-1/2 text-white text-5xl hover:text-gray-300 z-[4001] p-4">‚ùÆ</button>
            
            <!-- Â§ßÂõæÂÆπÂô® -->
            <div class="relative w-full h-full flex items-center justify-center p-10">
                <!-- Lightbox Loading Spinner -->
                <div v-if="isImageLoading" class="absolute inset-0 flex items-center justify-center z-50 text-white">
                    <svg class="animate-spin h-12 w-12" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                </div>

                <img :src="selectedItem.image_paths[currentImageIndex]" 
                     @load="onImageLoad"
                     v-show="!isImageLoading"
                     class="max-h-full max-w-full object-contain select-none shadow-2xl" 
                     alt="Full Screen Image">
            </div>
            
            <!-- Âè≥ÁÆ≠Â§¥ -->
            <button v-if="selectedItem.image_paths.length > 1" @click.stop="nextImage" class="absolute right-4 top-1/2 -translate-y-1/2 text-white text-5xl hover:text-gray-300 z-[4001] p-4">‚ùØ</button>
            
            <!-- Â∫ïÈÉ®ËÆ°Êï∞ -->
            <div class="absolute bottom-4 left-1/2 -translate-x-1/2 text-white bg-black/50 px-4 py-1 rounded-full font-mono">
                {{ currentImageIndex + 1 }} / {{ selectedItem.image_paths.length }}
            </div>
        </div>

    </div>

<script>
    const { createApp, ref, computed, watch, nextTick, reactive } = Vue;

    // Â∏∏ÈáèÂÆö‰πâ
    const ERA_SHAPES = { Early: "M10,0 A10,10 0 1,1 10,20 A10,10 0 1,1 10,0", Fatimid: "M2,2 H18 V18 H2 Z", Ayyubid: "M10,2 L18,18 H2 Z", Mamluk: "M10,0 L20,10 L10,20 L0,10 Z", Ottoman: "M10,0 L12.5,7.5 H20 L14,12.5 L16,20 L10,15 L4,20 L6,12.5 L0,7.5 H7.5 Z", Modern: "M5,0 L15,0 L20,10 L15,20 L5,20 L0,10 Z" };
    const DEFAULT_COLORS = { Faith: "#8b5cf6", Ruling: "#ef4444", Trade: "#10b981", Leisure: "#ec4899", Living: "#3b82f6", Production: "#f97316" };
    const SUB_CATEGORY_OPTIONS = { Ruling: [{ value: 'Gate', label: 'ÂüéÈó® (Gate/Bab)' }, { value: 'Wall', label: 'ÂüéÂ¢ô (Wall)' }, { value: 'Tower', label: 'Â°îÊ•º/Èò≤Âæ° (Tower)' }, { value: 'Palace', label: 'ÂÆ´ÊÆø (Palace/Qasr/Saraya)' }], Faith: [{ value: 'Mosque', label: 'Ê∏ÖÁúüÂØ∫ (Mosque)' }, { value: 'Madrasa', label: 'ÁªèÂ≠¶Èô¢ (Madrasa)' }, { value: 'Tomb', label: 'ÈôµÂ¢ì/Êã±Âåó (Tomb/Mausoleum)' }, { value: 'Sufi', label: 'ÈÅìÂ†Ç/ÂìàÂç° (Zawiya/Khanqah)' }, { value: 'Church', label: 'ÊïôÂ†Ç (Church)' }, { value: 'Synagogue', label: 'ÁäπÂ§™‰ºöÂ†Ç (Synagogue)' }, { value: 'Kuttab', label: 'Âè§ÂÖ∞ÁªèÂ≠¶Ê†° (Kuttab)' }], Trade: [{ value: 'Wikala', label: 'ÂïÜÊ†à (Wikala)' }, { value: 'Khan', label: 'Ê±ó/ÂïÜÊóÖÈ¶Ü (Khan)' }, { value: 'Market', label: 'Â∏ÇÂú∫/ËãèÂÖã (Souq/Badistan)' }], Leisure: [{ value: 'Sabil', label: 'ÂÖ¨ÁõäÈ•ÆÊ∞¥Â§Ñ (Sabil)' }, { value: 'Hawd', label: 'È•ÆÊ∞¥ÊßΩ (Hawd)' }, { value: 'Hammam', label: 'ÂÖ¨ÂÖ±Êæ°Â†Ç (Hammam)' }, { value: 'Library', label: 'Âõæ‰π¶È¶Ü (Library)' }, { value: 'Garden', label: 'Ëä±Âõ≠ (Garden)' }], Living: [{ value: 'House', label: 'Âè§ÂÆÖ (House/Bayt/Manzil)' }, { value: 'Rab', label: 'ÂÖ¨ÂØìÊ•º (Rab\')' }, { value: 'Hall', label: 'ÂéÖÂ†Ç (Qa\'a/Maq\'ad)' }], Production: [] };
    const ID_OVERRIDES = { "66": "Tomb", "180": "Mosque", "15": "Mosque", "28": "Mosque", "60": "Mosque", "187": "Mosque", "190": "Mosque", "480": "Mosque", "40": "Mosque", "43": "Mosque", "30": "Mosque", "42": "Mosque", "382": "Mosque", "459": "Mosque", "44": "Mosque", "35": "Madrasa", "38": "Madrasa", "428": "Madrasa", "96": "Madrasa", "105": "Tomb", "U32": "Tomb", "371": "Sufi", "74": "Sabil", "401": "Sabil", "16": "Sabil", "17": "Sabil", "70": "Sabil", "71": "Sabil", "179": "Sabil", "76": "Sabil", "230": "Sabil", "232": "Sabil", "236": "Sabil", "311": "Sabil", "358": "Sabil", "427": "Sabil", "553": "Sabil", "591": "Sabil", "562": "Hammam", "U30": "Hammam", "596": "Hammam", "U46": "Library", "406": "Market", "408": "Market", "235": "House", "U7": "House", "U20": "House", "65": "House", "72": "House", "471": "House", "487": "House", "489": "House", "500": "House", "501": "House", "50": "Palace" };
    const i18n = { zh: { viewList: "ÂàóË°®", viewMap: "Âú∞Âõæ", editMode: "ÁºñËæëÊ®°Âºè", exportData: "‰øùÂ≠òÊï∞ÊçÆ", unmappedList: "ÂæÖËêΩ‰Ωç", layerControl: "ÂõæÂ±ÇÁÆ°ÁêÜ", layerEra: "ÂéÜÂè≤Êó∂Êúü (ÂΩ¢Áä∂)", layerCategory: "ÂäüËÉΩÂàÜÁ±ª (È¢úËâ≤)", layerParentheses: "Â∑≤ÊãÜÈô§Âª∫Á≠ë (...)", labelId: "ÁºñÂè∑", labelMap: "ÂõæÂè∑", labelEra: "ÂéÜÂè≤Êó∂Êúü", labelCategory: "‰∏ªË¶ÅÁ±ªÂà´", labelSubCategory: "‰∫åÁ∫ßÂàÜÁ±ª", labelKeyword: "ÂÖ≥ÈîÆËØç", placeholderKeyword: "ÊêúÁ¥¢ÂêçÁß∞...", foundPrefix: "ÂÖ±", foundSuffix: "Â§Ñ", reset: "ÈáçÁΩÆ", noResult: "Êó†ÁªìÊûú", viewDetails: "ËØ¶ÊÉÖ", searchFilter: "ÊêúÁ¥¢‰∏éÁ≠õÈÄâ", eraAll: "ÂÖ®ÈÉ®Êó∂Êúü", catAll: "ÂÖ®ÈÉ®Á±ªÂûã (All)", subCatAll: "ÂÖ®ÈÉ®‰∫åÁ∫ßÂàÜÁ±ª", subCatHint: "ËØ∑ÂÖàÈÄâÊã©‰∏ªÁ±ªÂà´", eraEarly: "Êó©Êúü‰ºäÊñØÂÖ∞ (641-969)", eraFatimid: "Ê≥ïËíÇÁéõ (969-1171)", eraAyyubid: "ÈòøÂ∞§Â∏É (1171-1250)", eraMamluk: "È©¨Á©ÜÈ≤ÅÂÖã (1250-1517)", eraOttoman: "Â••ÊñØÊõº (1517-1805)", eraModern: "Ëøë‰ª£/ÈòøÈáå (1805-)", majorFaith: "‰ø°‰ª∞", majorRuling: "ÁªüÊ≤ª/Èò≤Âæ°", majorTrade: "Ë¥∏Êòì", majorLeisure: "‰ºëÈó≤/ÊúçÂä°", majorLiving: "Â±Ö‰Ωè", majorProduction: "Áîü‰∫ß", deleteConfirm: "Á°ÆÂÆöË¶ÅÁßªÈô§Ëøô‰∏™Âú∞ÁÇπÁöÑÊ†áËÆ∞ÂêóÔºü" }, en: { viewList: "List", viewMap: "Map", editMode: "Edit Mode", exportData: "Save Data", unmappedList: "Unmapped", layerControl: "Layers", layerEra: "Eras (Shape)", layerCategory: "Categories (Color)", layerParentheses: "Demolished Buildings (...)", labelId: "ID", labelMap: "Map", labelEra: "Era", labelCategory: "Main Category", labelSubCategory: "Sub Category", labelKeyword: "Keyword", placeholderKeyword: "Search name...", foundPrefix: "Found", foundSuffix: "items", reset: "Reset", noResult: "No results", viewDetails: "Details", searchFilter: "Search & Filter", eraAll: "All Eras", catAll: "All Types (All)", subCatAll: "All Sub-categories", subCatHint: "Select Major Category First", eraEarly: "Early Islamic (641-969)", eraFatimid: "Fatimid (969-1171)", eraAyyubid: "Ayyubid (1171-1250)", eraMamluk: "Mamluk (1250-1517)", eraOttoman: "Ottoman (1517-1805)", eraModern: "Modern (1805-)", majorFaith: "Faith", majorRuling: "Ruling/Defense", majorTrade: "Trade", majorLeisure: "Leisure", majorLiving: "Living", majorProduction: "Production", deleteConfirm: "Are you sure you want to remove this marker?" } };

    createApp({
        setup() {
            const currentView = ref('list');
            const currentLang = ref('zh');
            const isFullScreen = ref(false);
            const isEditMode = ref(false);
            const isSearchCollapsed = ref(false);
            const hideMapControls = ref(false);
            const mapError = ref(false);
            const showLayers = ref(true);
            const showMapLabels = ref(false); 
            const mapLabelFontSize = ref(12); 
            const showParenthesesLayer = ref(false); 
            const showPhotoIcons = ref(false);

            const exportIconScale = ref(100); 
            const exportTextScale = ref(100); 
            const searchId = ref("");
            const searchMap = ref("");
            const searchKeyword = ref("");
            const selectedCategory = ref("");
            const selectedSubCategory = ref(""); 
            const selectedEra = ref("");
            const selectedItem = ref(null);
            
            // ÂõæÁâáÊµèËßà‰∏éÈ¢ÑÂä†ËΩΩÁä∂ÊÄÅ
            const currentImageIndex = ref(0);
            const isImageLoading = ref(true);

            // ÁÅØÁÆ±Áä∂ÊÄÅ
            const isLightboxOpen = ref(false);
            
            // ‰∏ãËΩΩÁä∂ÊÄÅ
            const downloading = ref(false);

            const customColors = reactive({ ...DEFAULT_COLORS });
            const visibleLayers = reactive({ eras: Object.keys(ERA_SHAPES), cats: Object.keys(DEFAULT_COLORS) });
            const coordinates = ref({ ...SAVED_COORDINATES });
            const itemToMap = ref(null);
            let mapInstance = null;
            let markersLayer = null;
            let imageOverlay = null;

            const t = computed(() => i18n[currentLang.value]);
            const eraList = computed(() => [{ value: 'Early', label: t.value.eraEarly }, { value: 'Fatimid', label: t.value.eraFatimid }, { value: 'Ayyubid', label: t.value.eraAyyubid }, { value: 'Mamluk', label: t.value.eraMamluk }, { value: 'Ottoman', label: t.value.eraOttoman }, { value: 'Modern', label: t.value.eraModern }]);
            const categoryList = computed(() => [{ value: 'Faith', label: t.value.majorFaith }, { value: 'Ruling', label: t.value.majorRuling }, { value: 'Trade', label: t.value.majorTrade }, { value: 'Leisure', label: t.value.majorLeisure }, { value: 'Living', label: t.value.majorLiving }, { value: 'Production', label: t.value.majorProduction }]);
            const subCategoryList = computed(() => { if (!selectedCategory.value) return []; return SUB_CATEGORY_OPTIONS[selectedCategory.value] || []; });
            watch(selectedCategory, () => { selectedSubCategory.value = ""; });

            const wordToYear = { 'seventh': 600, 'eighth': 700, 'ninth': 800, 'tenth': 900, 'eleventh': 1000, 'twelfth': 1100, 'thirteenth': 1200, 'fourteenth': 1300, 'fifteenth': 1400, 'sixteenth': 1500, 'seventeenth': 1600, 'eighteenth': 1700, 'nineteenth': 1800, 'twentieth': 1900 };
            const getEraCategory = (d) => { if(!d) return 'Modern'; const s=d.toString().toLowerCase(); let y=null; const m=s.match(/AD\s*(\d{3,4})/i)||s.match(/\b(1\d{3}|20\d{2})\b/); if(m) y=parseInt(m[1]||m[0]); else { for(const[w,v]of Object.entries(wordToYear)) if(s.includes(w)&&s.includes('century')) if(!y||v>y) y=v; } if(!y) { if(s.includes('ottoman'))return 'Ottoman'; if(s.includes('mamluk'))return 'Mamluk'; if(s.includes('fatimid'))return 'Fatimid'; if(s.includes('ayyubid'))return 'Ayyubid'; return 'Modern'; } if(y<969)return 'Early'; if(y<1171)return 'Fatimid'; if(y<1250)return 'Ayyubid'; if(y<1517)return 'Mamluk'; if(y<1805)return 'Ottoman'; return 'Modern'; };
            const getEraLabel = (d) => t.value['era'+getEraCategory(d)];
            const getShortEra = (dating) => { const label = getEraLabel(dating); if (!label) return ""; return label.split(' (')[0]; }
            const identifySubCategory = (item) => { if (ID_OVERRIDES[item.id]) return ID_OVERRIDES[item.id]; const n = item.name.toLowerCase(); if (n.includes('synagogue') || n.includes('temple')) return 'Synagogue'; if (n.includes('hawd') || n.includes('trough')) return 'Hawd'; if (n.includes('hammam') || n.includes('bath')) return 'Hammam'; if (n.includes('sabil')) return 'Sabil'; if (n.includes('garden')) return 'Garden'; if (n.includes('museum') || n.includes('library')) return 'Library'; if (n.includes('palace') || n.includes('qasr') || n.includes('saraya') || n.includes('musafirkhana')) return 'Palace'; if (n.includes('gate') || n.includes('bab ')) return 'Gate'; if (n.includes('wall') || n.includes('tower') || n.includes('fortification')) return 'Wall'; if (n.includes('wikala') || n.includes('wakala')) return 'Wikala'; if (n.includes('khan ') || n.includes('khan,')) return 'Khan'; if (n.includes('badistan') || n.includes('souq') || n.includes('market') || n.includes('bazaar') || n.includes('qaysariya')) return 'Market'; if (n.includes('mosque') || n.includes('masjid') || n.includes('jami')) return 'Mosque'; if (n.includes('madrasa')) return 'Madrasa'; if (n.includes('tomb') || n.includes('mausoleum') || n.includes('qubba') || n.includes('shrine') || n.includes('turba') || n.includes('mashhad')) return 'Tomb'; if (n.includes('zawiya') || n.includes('khanqah') || n.includes('takiya') || n.includes('ribat')) return 'Sufi'; if (n.includes('church') || n.includes('convent') || n.includes('cathedral')) return 'Church'; if (n.includes('kuttab')) return 'Kuttab'; if (n.includes('house') || n.includes('bayt') || n.includes('manzil') || n.includes('dar ')) return 'House'; if (n.includes('rab\'') || n.includes(' rab ')) return 'Rab'; if (n.includes('qa\'a') || n.includes('maq\'ad') || n.includes('hall')) return 'Hall'; const d = (item.description || "").toLowerCase(); if (d.includes('mosque')) return 'Mosque'; if (d.includes('house')) return 'House'; return null; };
            const getMainCategoryBySub = (subKey) => { if (!subKey) return 'Faith'; for (const [mainKey, options] of Object.entries(SUB_CATEGORY_OPTIONS)) { if (options.find(opt => opt.value === subKey)) return mainKey; } return 'Faith'; };
            const getSubCategoryLabel = (item) => { const subKey = identifySubCategory(item); if (!subKey) return ""; const mainKey = getMainCategoryBySub(subKey); const options = SUB_CATEGORY_OPTIONS[mainKey]; const found = options.find(o => o.value === subKey); return found ? found.label : subKey; };
            const getCategoryInfo = (item) => { const subKey = identifySubCategory(item); const mainKey = getMainCategoryBySub(subKey); const color = customColors[mainKey] || '#666'; return { key: mainKey, style: { color: color, backgroundColor: `${color}15`, borderColor: `${color}40` }, label: t.value[`major${mainKey}`] }; };

            const filteredData = computed(() => { return FULL_DATABASE.filter(item => { if (searchId.value) { if (item.id.toString().toLowerCase() !== searchId.value.trim().toLowerCase()) { return false; } } if (searchMap.value && !item.map_sheet.includes(searchMap.value)) return false; if (searchKeyword.value) { const k = searchKeyword.value.toLowerCase(); if(!item.name.toLowerCase().includes(k)) return false; } if (selectedEra.value && getEraCategory(item.dating)!==selectedEra.value) return false; const subKey = identifySubCategory(item); const mainKey = getMainCategoryBySub(subKey); if (selectedCategory.value && mainKey !== selectedCategory.value) return false; if (selectedSubCategory.value && subKey !== selectedSubCategory.value) return false; return true; }); });
            const unmappedData = computed(() => filteredData.value.filter(i => !coordinates.value[i.id]));
            const hasFilters = computed(() => searchId.value||searchMap.value||searchKeyword.value||selectedCategory.value||selectedEra.value||selectedSubCategory.value);

            const selectItemToMap = (item) => { if (itemToMap.value && itemToMap.value.id === item.id) itemToMap.value = null; else itemToMap.value = item; };
            const switchView = (v) => { currentView.value = v; if(v === 'map') nextTick(() => { if(!mapInstance) initMap(); else mapInstance.invalidateSize(); }); };
            const toggleFullScreen = () => { isFullScreen.value = !isFullScreen.value; nextTick(() => mapInstance && mapInstance.invalidateSize()); };
            const getSvgIcon = (shapePath, color) => { return `<svg width="20" height="20" viewBox="0 0 20 20" style="filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.4)); overflow: visible;"><path d="${shapePath}" fill="${color}" stroke="white" stroke-width="1.5" /></svg>`; };

            // ‚òÖ‚òÖ‚òÖ ËøôÈáåÂ∑≤ÁªèÊîπ‰∏∫Âä†ËΩΩ map.webp ‚òÖ‚òÖ‚òÖ
            const initMap = () => { mapInstance = L.map('map-container', { crs: L.CRS.Simple, minZoom: -4, maxZoom: 3, zoomControl: false, attributionControl: false }); L.control.zoom({ position: 'topright' }).addTo(mapInstance); loadMapImage('map.webp'); mapInstance.on('click', (e) => { if(!isEditMode.value || !itemToMap.value) return; coordinates.value[itemToMap.value.id] = [e.latlng.lat, e.latlng.lng]; renderMarkers(); itemToMap.value = null; }); };
            
            const loadMapImage = (url) => { const img = new Image(); img.src = url; img.onload = () => { mapError.value = false; const b = [[0,0], [img.height, img.width]]; if(imageOverlay) mapInstance.removeLayer(imageOverlay); imageOverlay = L.imageOverlay(url, b).addTo(mapInstance); mapInstance.fitBounds(b); renderMarkers(); }; img.onerror = () => mapError.value = true; };
            const loadLocalImage = (e) => { const f=e.target.files[0]; if(f){ const r=new FileReader(); r.onload=ev=>loadMapImage(ev.target.result); r.readAsDataURL(f); } };

            const renderMarkers = () => {
                if (!mapInstance) return;
                if (markersLayer) mapInstance.removeLayer(markersLayer);
                markersLayer = L.layerGroup().addTo(mapInstance);

                filteredData.value.forEach(item => {
                    const coords = coordinates.value[item.id];
                    if (coords) {
                        const eraKey = getEraCategory(item.dating);
                        const subKey = identifySubCategory(item);
                        const mainKey = getMainCategoryBySub(subKey);
                        if (!visibleLayers.eras.includes(eraKey)) return;
                        if (!visibleLayers.cats.includes(mainKey)) return;
                        const shape = ERA_SHAPES[eraKey] || ERA_SHAPES.Modern;
                        let color = customColors[mainKey] || '#999';
                        const hasParentheses = item.id.includes('(') || item.id.includes(')');
                        if (showParenthesesLayer.value && hasParentheses) { color = '#000000'; }
                        
                        let markerHtml = `<div class="relative">${getSvgIcon(shape, color)}`;
                        if (showPhotoIcons.value && item.image_paths && item.image_paths.length > 0) {
                            markerHtml += `<div class="photo-badge">üì∑</div>`;
                        }
                        markerHtml += `</div>`;

                        const icon = L.divIcon({ html: markerHtml, className: 'custom-marker', iconSize: [20, 20], iconAnchor: [10, 10] });
                        const marker = L.marker(coords, { icon: icon, draggable: isEditMode.value });
                        marker.on('dragend', (e) => coordinates.value[item.id] = [e.target.getLatLng().lat, e.target.getLatLng().lng]);
                        marker.on('click', () => openModal(item));
                        marker.on('contextmenu', (e) => { if(isEditMode.value) { L.DomEvent.stopPropagation(e); deleteMarker(item.id); } });
                        if (showMapLabels.value) { marker.bindTooltip(`<span style="font-size: ${mapLabelFontSize.value}px">#${item.id} ${item.name}</span>`, { permanent: true, direction: 'right', className: 'map-label-tooltip', offset: [10, 0] }); } else { marker.bindTooltip(`<b>#${item.id}</b> ${item.name}`, { direction: 'top', offset: [0, -10] }); }
                        markersLayer.addLayer(marker);
                    }
                });
            };

            const deleteMarker = (id) => { if (!confirm(t.value.deleteConfirm)) return; delete coordinates.value[id]; if (selectedItem.value && selectedItem.value.id === id) { closeModal(); } renderMarkers(); };
            
            const exportFullMap = async () => { if (!imageOverlay || !imageOverlay._image) { alert("Map not loaded."); return; } const originalImg = imageOverlay._image; const width = originalImg.naturalWidth; const height = originalImg.naturalHeight; if (width === 0 || height === 0) return; const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height; const ctx = canvas.getContext('2d'); ctx.drawImage(originalImg, 0, 0); const baseScale = Math.max(1.0, width / 2500); const finalIconScale = baseScale * (exportIconScale.value / 100); const finalTextScale = baseScale * (exportTextScale.value / 100); ctx.textAlign = "center"; ctx.textBaseline = "top"; filteredData.value.forEach(item => { const coords = coordinates.value[item.id]; if (!coords) return; const eraKey = getEraCategory(item.dating); const subKey = identifySubCategory(item); const mainKey = getMainCategoryBySub(subKey); if (!visibleLayers.eras.includes(eraKey)) return; if (!visibleLayers.cats.includes(mainKey)) return; const x = coords[1]; const y = height - coords[0]; const shapePathStr = ERA_SHAPES[eraKey] || ERA_SHAPES.Modern; let color = customColors[mainKey] || '#999'; const hasParentheses = item.id.includes('(') || item.id.includes(')'); if (showParenthesesLayer.value && hasParentheses) { color = '#000000'; } ctx.save(); ctx.translate(x, y); ctx.scale(finalIconScale, finalIconScale); ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.shadowBlur = 4; ctx.shadowOffsetY = 2; const p = new Path2D(shapePathStr); ctx.translate(-10, -10); ctx.fillStyle = color; ctx.fill(p); ctx.lineWidth = 1; ctx.strokeStyle = "white"; ctx.shadowColor = "transparent"; ctx.stroke(p); ctx.restore(); if (exportTextScale.value > 0) { const fontSize = Math.max(10, 14 * finalTextScale); ctx.font = `bold ${fontSize}px sans-serif`; ctx.fillStyle = "#000"; ctx.lineWidth = 3; ctx.strokeStyle = "rgba(255,255,255,0.8)"; const labelText = item.map_sheet ? `#${item.id} (M:${item.map_sheet})` : `#${item.id}`; const labelOffsetY = (14 * finalIconScale); ctx.strokeText(labelText, x, y + labelOffsetY); ctx.fillText(labelText, x, y + labelOffsetY); } }); try { const link = document.createElement('a'); link.download = `Cairo_FullMap_${new Date().toISOString().slice(0,10)}_I${exportIconScale.value}_T${exportTextScale.value}.jpg`; link.href = canvas.toDataURL('image/jpeg', 0.85); link.click(); } catch (e) { console.error(e); alert("Export failed."); } };

            const toggleAll = (type) => { const all = type === 'eras' ? Object.keys(ERA_SHAPES) : Object.keys(DEFAULT_COLORS); if (visibleLayers[type].length === all.length) visibleLayers[type] = []; else visibleLayers[type] = all; };
            const resetColors = () => { Object.assign(customColors, DEFAULT_COLORS); };
            
            watch([filteredData, isEditMode, visibleLayers, customColors, showParenthesesLayer, showMapLabels, mapLabelFontSize, showPhotoIcons], () => { if(currentView.value === 'map') renderMarkers(); }, { deep: true });
            
            const exportCoordinates = () => { navigator.clipboard.writeText(JSON.stringify(coordinates.value, null, 4)).then(() => alert("Coordinates copied to clipboard!")); };
            const resetSearch = () => { searchId.value=""; searchMap.value=""; searchKeyword.value=""; selectedCategory.value=""; selectedSubCategory.value=""; selectedEra.value=""; };
            const openModal = (item) => { selectedItem.value = item; };
            const closeModal = () => { selectedItem.value = null; isLightboxOpen.value = false; };
            const toggleLang = () => { currentLang.value = currentLang.value === 'zh' ? 'en' : 'zh'; };
            const googleTranslateUrl = computed(() => selectedItem.value ? `https://translate.google.com/?sl=en&tl=zh-CN&text=${encodeURIComponent(selectedItem.value.description)}&op=translate` : "#");
            const getSvgPath = (d) => d; 

            // ============ ÂõæÁâá‰ºòÂåñÁõ∏ÂÖ≥ÈÄªËæë ============
            
            // È¢ÑÂä†ËΩΩÂäüËÉΩ
            const preloadImages = (urls) => {
                if (!urls || urls.length === 0) return;
                urls.forEach(url => {
                    const img = new Image();
                    img.src = url;
                });
            };

            // ÂΩìÂõæÁâáÊ†áÁ≠æËß¶Âèë @load ‰∫ã‰ª∂Êó∂
            const onImageLoad = () => {
                isImageLoading.value = false;
            };

            // ÁõëÂê¨ÈÄâ‰∏≠È°πÂèòÂåñÔºåÈáçÁΩÆÁ¥¢ÂºïÂπ∂È¢ÑÂä†ËΩΩ
            watch(selectedItem, (newItem) => { 
                currentImageIndex.value = 0; 
                isImageLoading.value = true;
                if (newItem && newItem.image_paths && newItem.image_paths.length > 0) {
                    preloadImages(newItem.image_paths);
                }
            });

            const nextImage = () => { 
                if (selectedItem.value && selectedItem.value.image_paths) { 
                    isImageLoading.value = true;
                    currentImageIndex.value = (currentImageIndex.value + 1) % selectedItem.value.image_paths.length; 
                } 
            };
            const prevImage = () => { 
                if (selectedItem.value && selectedItem.value.image_paths) { 
                    isImageLoading.value = true;
                    currentImageIndex.value = (currentImageIndex.value - 1 + selectedItem.value.image_paths.length) % selectedItem.value.image_paths.length; 
                } 
            };
            
            // ÁÅØÁÆ±
            const openLightbox = () => { isLightboxOpen.value = true; };
            const closeLightbox = () => { isLightboxOpen.value = false; };
            
            // ‰∏ãËΩΩÂäüËÉΩ
            const downloadImages = async () => {
                if (!selectedItem.value || !selectedItem.value.image_paths || selectedItem.value.image_paths.length === 0) return;
                
                downloading.value = true;
                const zip = new JSZip();
                const safeName = selectedItem.value.name.replace(/[^a-z0-9]/gi, '_').replace(/_+/g, '_');
                const folderName = `${selectedItem.value.id}_${safeName}`;

                try {
                    const promises = selectedItem.value.image_paths.map(async (url) => {
                        const response = await fetch(url);
                        if (!response.ok) throw new Error(`Failed to fetch ${url}`);
                        const blob = await response.blob();
                        const filename = url.substring(url.lastIndexOf('/') + 1);
                        const decodedFilename = decodeURIComponent(filename);
                        zip.file(decodedFilename, blob);
                    });

                    await Promise.all(promises);
                    const content = await zip.generateAsync({ type: "blob" });
                    saveAs(content, `${folderName}.zip`);
                } catch (error) {
                    console.error("Download failed:", error);
                    alert("Download failed. Please check console for details.");
                } finally {
                    downloading.value = false;
                }
            };

            return {
                currentView, currentLang, isFullScreen, isEditMode, isSearchCollapsed, hideMapControls, mapError,
                searchId, searchMap, searchKeyword, selectedCategory, selectedSubCategory, selectedEra, selectedItem,
                filteredData, unmappedData, itemToMap, coordinates, savedCoordinates: coordinates,
                t, hasFilters, switchView, toggleFullScreen, loadLocalImage, exportCoordinates,
                resetSearch, openModal, closeModal, toggleLang, googleTranslateUrl,
                getCategoryInfo, getEraLabel, identifySubCategory, getSubCategoryLabel,
                showLayers, visibleLayers, eraShapes: ERA_SHAPES, catColors: DEFAULT_COLORS, getSvgPath, toggleAll,
                selectItemToMap, eraList, categoryList, subCategoryList, getShortEra,
                deleteMarker, exportFullMap, customColors, resetColors,
                exportIconScale, exportTextScale, showParenthesesLayer,
                showMapLabels, mapLabelFontSize,
                
                // ÂõæÁâáÁõ∏ÂÖ≥
                currentImageIndex, nextImage, prevImage, showPhotoIcons,
                isImageLoading, onImageLoad, // ÂØºÂá∫Êñ∞ÂèòÈáè
                // ÁÅØÁÆ±
                isLightboxOpen, openLightbox, closeLightbox,
                // ‰∏ãËΩΩ
                downloadImages, downloading
            };
        }
    }).mount('#app');
</script>
</body>
</html>